---
title: "Order book reconstruction from quotes and trades streams"
author: "Petr Fedorov"
date: "`r Sys.Date()`"
output:
  bookdown::gitbook:
    number_sections: TRUE
    figure_captions: TRUE
bibliography: coupling.bib    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(scipen = 999, digits = 6, digits.secs=6)
library(data.table)
library(huxtable)
library(magrittr)
load("coupling.Rdata")
#futile.logger::flog.threshold(futile.logger::WARN, 'obadiah')

```



```{r Load Bitstamp data, eval=FALSE}
load(file="bitstamp.Rdata")
setDT(bitstamp.trades)
setDT(bitstamp.quotes)
```

```{r Load Bitfinex data, eval=FALSE}
load(file="bitfinex.Rdata")
setDT(bitfinex.trades)
setDT(bitfinex.quotes)

```


```{r Prepare coupling.Rdata, eval=FALSE}
bitstamp.quotes[order(microtimestamp), c("volume.decrease", "k") := .(nafill(shift(amount,1),fill=0) - amount, seq_len(.N)), by=order_id]

stamp.digits <- 4

stamp.q.1 <- bitstamp.quotes[between(microtimestamp,'2020-03-25 12:17:23+03','2020-03-25 12:17:24+03'), .(microtimestamp, order_id, k, price, amount, volume.decrease=round(volume.decrease,stamp.digits), order_type,  event=fifelse(event=='order_deleted', 'D', fifelse(event=='order_created', 'A',  'C') ), local_timestamp, n=.I )]

stamp.t.1 <- bitstamp.trades[between(trade_timestamp,'2020-03-25 12:17:23+03','2020-03-25 12:17:24+03'), .(bitstamp_trade_id, amount=round(amount, stamp.digits), price=round(price, stamp.digits), trade_type, trade_timestamp, buy_order_id, sell_order_id, local_timestamp, n=.I) ]

bitfinex.quotes[order(exchange_timestamp), c("price", "event","amount") := .(fifelse(price != 0, price, shift(price,1)), fifelse(nafill(shift(price,1), fill=0) == 0, 'A', fifelse(price == 0, 'D','C')), fifelse(price==0, 0, amount) ), by=order_id]

bitfinex.quotes[order(exchange_timestamp), c("volume.decrease", "k") := .(abs(nafill(shift(amount,1),fill=0)) - abs(amount), seq_len(.N)), by=order_id]

finex.digits <- 5

finex.q.1 <- bitfinex.quotes[between(exchange_timestamp,'2020-03-26 07:01:33+03','2020-03-26 07:01:34+03')][order(local_timestamp), .(exchange_timestamp, order_id, price=round(price, finex.digits), amount=round(amount, finex.digits), event, volume.decrease=round(volume.decrease, finex.digits), k, local_timestamp, n=.I) ]
finex.t.1 <- bitfinex.trades[between(exchange_timestamp,'2020-03-26 07:01:33+03','2020-03-26 07:01:34+03')][order(local_timestamp), .(id, qty, price=round(price, finex.digits), exchange_timestamp, trade_id, local_timestamp, n=.I)]
finex.t.1[, c("qty", "d") := .(round(abs(qty), finex.digits), ifelse(qty > 0, -1, 1))]

save(stamp.q.1, stamp.t.1, finex.q.1, finex.t.1, file="coupling.Rdata", compress=TRUE)

```



 
# Introduction


## Continous-time double auction and LOB


Today, most liquid markets – including stocks, futures, and foreign exchange – are electronic, and adopt a continuous-time double auction mechanism using a limit order book (LOB), in which a transaction occurs whenever a buyer and a seller agree on a price[@bouchaud_trades_2018]. Cryptocurrenices are not exception. 

The mechanics of the countinous double auction or LOB trading may be briefly described as follows: 

1. Traders submit *limit orders* also called *quotes* and *market* or *market-limit* orders (i.e. quotes with the limit price better than the opposite quote best price already in LOB) 
<!-- 2. *Market* or *market-limit* orders are [matched](https://www.investopedia.com/terms/m/matchingorders.asp) with *quotes*  and executed to produce *trades*. -->
3. Unmatched *quotes* or unmatched amounts of *market-limit* orders reside in LOB's queues until matched with another *market* or *market-limit* order or cancelled by the participant who submitted it.

Market or market-limit orders are also often called *taker* orders while limit orders sitting in queues are called *maker* orders.

Note that not all matched orders are executed and produce trades. This happens due to self-match or self-trade prevention rules. See for example [CME Globex Self-Match Prevention](https://www.cmegroup.com/globex/trade-on-cme-globex/self-match-faq.html) or [Coinbase Markets Trading Rules 2.4 Self-trade prevention](https://www.coinbase.com/legal/trading_rules).

Thus in order to reconstruct the dynamics of the trading process and order book one needs  information about submitted quotes, market and market-limit orders and trades produced. As we will see below this information is not always provided by exchanges.


## Available data sets

Most of data sets containing information about quotes and trades consist of two separate loosely coupled files: a **trades** file recording  trades and an **quotes** file recording quote placements, changes and cancellations. Loosely coupled in this context means that records in **trades** file do not always have clearly identifiable corresponding records in **quotes** file as one would expect. By definition every trade shoud change some quote in LOB. So a matching or *coupling* procedure is required in order to establish the link between the **trades** and **quotes** files. This link is necessary to:

* Distinguish between quote changes due to limit order cancellation and market order execution
* Estimate size of submitted market orders
* Distinquish between limit order placements and market limit order placements

and, overall, to achieve the ultimate goal - to perform a complete order book reconstruction at every moment of time.

A recently published book [@abergel_limit_2016] uses the [Thomson Reuters Tick History (TRTH)](https://www.refinitiv.com/en/financial-data/market-data/tick-history) database tells us that

> Because one cannot distinguish market orders from cancellations just by observing changes in the limit order book (the “event” file), and since, the timestamps of the “trade” and “event” files are asynchronous, we use a matching procedure to reconstruct the order book events.

The reported matching rate of the above procedure is about 85% for CAC 40 stocks and as a byproduct the procedure outputs the sign of each matched trade, that is whether it is a buyer or a seller initiated trade. Note that TRTH data set does not even provide information about trade direction, it has to be deduced!

The description of similar issues we find in [@hautsch_modelling_2004]:

> A typical problem occurs when trades and quotes are recorded in separate trade and quote databases, like, for example, in the Trade and Quote (TAQ) database released by the NYSE. In this case, it is not directly identifiable whether a quote which has been posted some seconds before a transaction was already valid at the corresponding trade.

[Websocket API v2](https://www.bitstamp.net/websocket/v2/) of the cryptocurrency exchange Bitstamp gives access to the following information for every instrument traded:

 * **Live ticker** channel - information about trades. Unique ids of participating quote and market order are provided for each trade.
 * **Live orders** channel - information about quotes and market orders (all order creation, change and deletion events are reported).

As we will see later, events in these channels are not always sent in correct time order. It seems that some events are ommitted. Timestamps in Live tickers and Live orders channels are not synchronized: market order, changes of quotes and of market order itself caused by the execution of the market order, trades produced - all may have different timestamps. Substantial amount of matched orders are not executed due to [self-trade prevention](https://www.reddit.com/r/Bitstamp/comments/bbvut2/bitstamp_api_behaviour/?utm_source=share&utm_medium=web2x) policy of Bitstamp.
 

Similarly [Websocket API version 2.0] of the cryptocurrency exchange Bitfinex have the following channels (for every instrument traded):

 * **Trades** channel - information about trades. Ids of participating quote and market orders are not reported
 * **Raw book** channel - provides information about 100 best bid and 100 ask quotes. Market orders are not reported. Quotes reported as deleted when they fall beyond 100+ best quotes and created again with the same id when they return back. What was happening to them between these moments is not known. Since Bitfinex allows traders to change the price and volume of submitted quotes, the quotes may be changed or just cancelled. 
 
As well as at Bitstamp, records in Trades and Raw book channels are not synchronized.

It should be clear from the above that substantial effort is required to reconstruct the true dynamics of order submission, matching and execution.

# Reconstruction algorithm

## Order

Consider a definition given in [@bouchaud_trades_2018]:


> An order is a commitment, declared at a given submission time, to buy or sell a given volume of an asset at no worse than a given price. An order $x$ is thus described by four attributes:
>
> * its sign (or direction) $\epsilon = \pm 1$, ($\epsilon_x = +1$ for buy orders; $\epsilon_x = −1$ for sell orders),
  * its price $p_x$ ,
  * its volume $v_x > 0$, and
  * its submission time $t_x$.
>  
> We introduce the succinct notation $x := (\epsilon_x , p_x ,v_x, t_x )$.

[@bouchaud_trades_2018] then continues with a description of what they call The Trade-Matching Algorithm:

> Whenever a trader submits a buy (respectively, sell) order $x$, an LOB’s *trade-matching algorithm* checks whether it is possible for $x$ to match to existing sell (respectively,buy)orders $y$ such that $p_y \leq p_x$ (respectively, $p_y \geq p_x$). If so, the matching occurs immediately and the relevant traders perform a trade for the agreed amount at the agreed price. Any portion of $x$ that does not match instead becomes active at the price $p_x$, and it remains active until either it matches to an incoming sell (respectively, buy) order or it is cancelled. Cancellation usually occurs when the owner of an order no longer wishes to offer a trade at the stated price.

Above definition and description are incomplete:

* According to the definition, an order $x$ seems to be an immutable entity. But according to the Trade-Matching algorithm, a portion of $x$ may become 'active' and it is not clear how the quality of being 'active' is different from the mere existence of submitted orders,

* At what price the trade is performed - $p_x$ or $p_y$ - is not explicitly stated,

* It is not stated what will happen if $v_x \leq v_y$, etc. 

Surprisingly, the concept of order and operations of a continous double auction appear to be rather complicated things if one attempts to define them rigorously!

Hereafter is assumed that a single asset is traded and a single currency is used. 

```{definition Order, name="Order", label=order}
Suppose that:

a. $i \in \mathbb{N}$ is called an *unique order identification*, 
a. $\mathcal{T^i}$ is a set of intervals $\mathcal{T^i} = \{T_k^i\}_{k=0}^{K^i}$ called *order intervals* where each $T_k^i$ is either a proper interval with endpoints $s_k^i \in \mathbb{R}_{>0}$, $e_k^i \in \mathbb{R}_{>0} \cup \{+\infty\}$, $s_k^i < e_k^i$  or a degenerate interval $\{s_k^i\}, s_k^i \in \mathbb{R}_{>0}$ and $\forall m \neq n : T_m^i \cap T_n^i = \emptyset$,

b. $\chi_{T_k^i} : \mathbb{R} \mapsto \{0,1\}$ is an indicator function of intervals in $\mathcal{T^i}$: 
$\chi_{T_k^i}(t) = \begin{cases} 1, & t \in T_k^i \\ 0, & \text{otherwise} \end{cases}$,

b. $\mathcal{P}^i = \{p_k^i\}_{k=0}^{K^i}$ is a set of constants $p_k^i \in \mathbb{R}_{>0}$ called *order prices*,

c. $\mathcal{V}^i = \{v_k^i\}_{k=0}^{K^i}$ is a set of constants called *order volumes*, such that either  $v_k^i \in \mathbb{R}_{<0}$ or $v_k^i \in \mathbb{R}_{>0}$,
  
d. Sets $\mathcal{P}^i$ and $\mathcal{V}^i$  satisfy the following condition $\forall k  \in [0, \ldots, N_i) : (p_k^i, v_k^i) \neq (p_{k+1}^i, v_{k+1}^i)$,

Then a vector-valued function $\mathbf{o}^i(t) : \mathbb{R}_{>0} \mapsto \mathbb{R}_{>0} \times \mathbb{R}$ representing a commitment to buy or sell a given volume $v$ of an asset at no worse than a given price $p$ at a particular time $t$  with a closed form:
$$
  \mathbf{o}^i(t) = (p^i(t), v^i(t)) = \Big( \sum_{k=1}^{K^i} p_k^i \chi_{T_k^i}(t),  \sum_{k=1}^{K^i} v_k^i \chi_{T_k^i}(t) \Big)
$$ is called an *order*. If $v_k^i \in \mathbb{R}_{<0}$ the order is a commitment to *sell* and is also called a *sell order*. If $v_k^i \in \mathbb{R}_{>0}$ the order is a commitment to *buy* and is also called a *buy order*.
```

Whenever it is clear from the context, we may also use the word order for:

 * An unique order identification $i$ number
 * An order as defined in [@bouchaud_trades_2018] (see above)
 * The value of tuple $(i, p^i(t_0), v^i(t_0))$ at the particular time $t_0$
 
Now we can define

```{definition Order Volume, name="Order Volume", label=order-volume}
The function $v^i(t)$ in definition \@ref(def:order) is called an *order volume*.
```


```{definition Order Price, name="Order Price", label=order-price}
The function $p^i(t)$ in definition \@ref(def:order) is called an *order price*.
```


```{definition Filled Volume and Trade, name="Filled Volume and Trade", label=fill-volume}
The filled volume $f^i(t)$ of an order $i$ at time $t$ is defined as: 
  $$
  f^i(t) = v^i(t) - \lim_{t^{'} \downarrow t} v^i(t^{'})
  $$
The tuple $(t, f^i(t), p^i(t))$ is called a *trade*. If order $i$ is a buy order then the trade is called a *sell trade*.  Otherwise it is a *buy trade*.
```

```{definition Cancelled Volume, name="Cancelled Volume", label=cancelled-volume}
The cancelled volume $c^i(t)$ of an order $i$ at time $t$ is defined as: 
  $$
  c^i(t) = \lim_{t^{'} \uparrow t} v^i(t^{'}) - v^i(t)
  $$
  
```




## Order Book

```{definition Order Book, name="Order Book", label=order-book}
A set of orders $\mathcal{O} = \{\mathbf{o}^i(t)\}_i$ is called an *order book*.
```


```{definition Order Placement Policy, name="Order Placement Policy", label=order-placement-policy}
Suppose that $\mathbb{O}$ is a set of all Order Books $\mathcal{O}$ as defined by \@ref(def:order-book). The function $$\mathcal{P}(\mathcal{O},i, t, p, v) : \mathbb{O} \times \mathbb{N} \times  \mathbb{R}_{>0} \times \mathbb{R}_{>0} \times \mathbb{R}_{\neq 0} \mapsto \mathbb{O}$$ is called an *order placement policy*. It defines how order $i$ placement or update submitted at time $t$ with price $p$ and volume $v$ is added to the order book $\mathcal{O}$ and how the existing orders in $\mathcal{O}$ are modified, if necessesary. 
```


```{definition Best Bid Price, name="Best Bid Price", label=best-bid-price}
Suppose we are given an order book $\mathcal{O}$.  A (possibly empty) subset $\mathcal{B} =\{\mathbf{o}^b(t)\}_{v_k^b > 0} \subset \mathcal{O}$ of buy orders is called *bids* and the function $b(t)$ is defined as:
  $$
  b_{\mathcal{O}}(t) = \begin{cases} \max_{\mathbf{o}^b(t) \in \mathcal{B}} p^b(t), & \text{ if } \mathcal{B} \neq \emptyset \\0, & \text{ otherwise }  \end{cases}
  $$ is called *best bid price*.
```


```{definition Best Ask Price, name="Best Ask Price", label=best-ask-price}
Suppose we are given an order book $\mathcal{O}$. A (possibly empty) subset $\mathcal{A} =\{\mathbf{o}^a(t)\}_{v_k^a < 0} \subset \mathcal{O}$ of sell orders is called *asks* and the function $a(t)$ is defined as:
  $$
  a_{\mathcal{O}}(t) = \begin{cases} \min_{\mathbf{o}^a(t) \in \mathcal{A}} p^a(t) & \text{ if } \mathcal{A} \neq \emptyset \\ +\infty, & \text{ otherwise } \end{cases}
  $$ is called *best ask price*.
```

```{definition Matched Orders, name="Matched Orders", label=match}
Suppose we are given an order book $\mathcal{O}$. A buy order $\mathbf{o}^b(t) \in \mathcal{O}$ and a sell order $\mathbf{o}^s(t) \in \mathcal{O}$ are called *matched* if $\exists t : p^b(t) \geq p^s(t)$. If $$\lim_{t^{'} \uparrow t} p^s(t) \neq p^s(t)$$ then $\mathbf{o}^s(t)$ is called a *taker* order and $\mathbf{o}^b(t)$ is called a *maker* order. Otherwise, $\mathbf{o}^b(t)$ is called a *taker* order and $\mathbf{o}^s(t)$ is called a *maker* order.
The set of matched buy orders at time $t$ we will denote $\mathcal{M}_{\text{bid}}(t)$ and the set of matched sell orders - $\mathcal{M}_{\text{ask}}(t)$.
```



```{definition Ideal Order Book, name="Ideal Order Book", label=iob}
Suppose we are given an order book $\mathcal{O}$.  Then $\mathcal{O}$ is called *Ideal Order Book (IOB)* if the following conditions are satisfied: 
  
  a. Instantaneous Match Execution (IME)
$$ \lambda \Big( \{t : b_{\mathcal{O}}(t) \geq a_{\mathcal{O}}(t)\}\Big) = 0
(\#eq:instant-match)
  $$ where $\lambda(X)$ is the Lebesgue measure of set $X$.
  b. Volume Conservation (VC)
  $$
    \forall t \in \{t : b_{\mathcal{O}}(t) \geq a_{\mathcal{O}}(t)\} : \sum_{\mathbf{o}^b(t) \in \mathcal{M}_{\text{bid}}(t)} f^b(t) = \sum_{\mathbf{o}^s(t) \in \mathcal{M}_{\text{ask}}(t)} |f^s(t)|
    (\#eq:volume-conservation)
    $$

```



To make these definitions intuitevely clear, let's consider how IOB $\mathcal{O}$ would evolve under some  order placement policy $\mathcal{P}$ in a typical scenario of placing several buy and sell orders.  Note that our policy $\mathcal{P}$ given IOB retuns IOB. It is not the case in general and another order placement policy could retrun order book which is not IOB.

 1. A buy order is submitted at time $t_1$ with the price $p_1$ and volume $v_1$ and is transformed by $\mathcal{P}$ into $\mathbf{o}^1(t)$:
 
    + $\mathbf{o}^1(t)$ is added to $\mathcal{O}$: $$
\mathbf{o}^1(t) = \left[
 \begin{eqnarray}
  \mathcal{T}^1 & = & \{ [t_1, +\infty) \} \\
  \mathcal{P}^1 & = & \{ p_1 \} \\
  \mathcal{V}^1 & = & \{ v_1 \}
 \end{eqnarray} 
 \right.
 $$
 2. A sell order with price $p_2 < p_1$ and volume $|v_2| < |v_1|$ is submitted and transformed into $\mathbf{o}^2(t)$, matched with $\mathbf{o}^1(t)$ so the latter is partially filled at time $t_2$. All these actions are performed by $\mathcal{P}$. Note that the right endpoint $t_2$ below is included:
 
    + $\mathbf{o}^1(t)$ is changed: $$
    \mathbf{o}^1(t) = \left[
     \begin{eqnarray}
      \mathcal{T}^1 & = & \{ [t_1, t_2], (t_2, +\infty] \} \\
      \mathcal{P}^1 & = & \{ p_1, p_1 \} \\
      \mathcal{V}^1 & = & \{ v_1, v_1 - v_2 \}
    \end{eqnarray}
    \right.
  $$
    + $\mathbf{o}^2(t)$ is added to $\mathcal{O}$: $$
    \mathbf{o}^2(t) = \left[
     \begin{eqnarray}
      \mathcal{T}^2 & = & \{ {t_2} \} \\
      \mathcal{P}^2 & = & \{ p_2 \} \\
      \mathcal{V}^2 & = & \{ v_2 \}
    \end{eqnarray}
    \right.
  $$
 3. A sell order with price $p_3 < p_1$ and volume $v_3$ is submitted by the same trader as the one who submitted $\mathbf{o}^1(t)$. The order is transformed into $\mathbf{o}^3(t)$ and $\mathbf{o}^1(t)$ is cancelled (note that the right endpoint $t_3$ below is not included) due to self-trade prevention policy, which is part of $\mathcal{P}$, at time $t_3$ (as, for example, CME Globex would do by default):
    + $\mathbf{o}^1(t)$ is changed: $$
    \mathbf{o}^1(t) = \left[
     \begin{eqnarray}
      \mathcal{T}^1 & = & \{ [t_1, t_2], (t_2, t_3) \} \\
      \mathcal{P}^1 & = & \{ p_1, p_1 \} \\
      \mathcal{V}^1 & = & \{ v_1, v_1 - v_2 \}
    \end{eqnarray}
    \right.
  $$
    + $\mathbf{o}^2(t)$ remains the same,
    + $\mathbf{o}^3(t)$ is added to $\mathcal{O}$: $$
    \mathbf{o}^3(t) = \left[
     \begin{eqnarray}
      \mathcal{T}^3 & = & \{ [t_3, +\infty) \} \\
      \mathcal{P}^3 & = & \{ p_3 \} \\
      \mathcal{V}^3 & = & \{ v_3 \}
    \end{eqnarray}
    \right.
  $$


## Quotes and Trades Streams

Formally speaking, the reconstruction algorithm is supposed to produce Ideal Order Book from non-ideal data - Quotes and Trades Streams - provided by an exchange.  The effort required varies by an exchange. For example [MOEX](https://www.moex.com/) provides data of close to ideal quality while [Bitfinex](https://www.moex.com/) does not report unique order identifications for trades and omits market orders altogether.


```{definition Quote Event, name="Quote Event", label=quote-event}
A tuple $\mathcal{S}_Q^i[k] = (t_k^i, i, k, p_k^i, v_k^i, e^k_i)$  where

 a. $t_k^i \in \mathbb{R}_{> 0}$ is a timestamp,
 b. $i \in \mathbb{N}$ is an identification number of the quote,
 b. $k \in \mathbb{N}$ is a quote event number, 
 c. $p_k^i \in \mathbb{R}_{\geq 0}$ is a quote price at $t_k^i$,
 d. $v_k^i \in \mathbb{R}$ is a quote volume since $t_k^i$,
 f. $e_k^i \in \{ A, C, D \}$ is an event type: $A$ stands for addition to an order book event, $C$ stands for change event and $D$ stands for deletion from an order book,
 
is called *quote $i$ event number $k$*.
```


```{definition Quote, name="Quote", label=quote}
A set of quote event tuples $\mathcal{S}_Q^i =\{\mathcal{S}_Q^i[k] \}_{k=1}^{K^i} = \{(t_k^i, i, k, p_k^i, v_k^i, e^k_i)\}_{k=1}^{K^i}$ where

a. $k_1 < k_2 \implies t_{k_1}^i \leq t_{k_2}^i$, 
a. all $v_k^i$ are either non-negative or non-positive

is called *quote $i$*. If all $v_k^i \leq 0$ then the quote is a *sell quote*. Otherwise it is a *buy quote*.

```


```{definition Volume Decreasing Quote Event, name="Volume Decreasing Quote Event", label=volume-decreasing-quote-event}

Suppose a quote $\mathcal{S}_Q^i =\{\mathcal{S}_Q^i[k] \}_{k=1}^{K^i} = \{(t_k^i, i, k, p_k^i, v_k^i, e^k_i)\}_{k=1}^{K^i}$ as defined by \@ref(def:quote) is given. The value $$\Delta v_k^i = |v_{k-1}^i| - |v_k^i|, k > 1$$ is called a *volume decrease of quote $i$ event $k$*. A volume decrease of quote $i$ event $1$ is undefined.  A quote event $\mathcal{S}_Q^i[k] \in \mathcal{S}_Q^i$ is called a *volume decreasing quote event* if it has a positive volume decrease, i.e. if $|v_k^i| < |v_{k-1}^i|$. 
```



```{definition Quotes Stream, name="Quotes Stream", label=quotes-stream}
A union of quotes $$\mathcal{S}_Q = \bigcup_i \mathcal{S}_Q^i = \bigcup_i \{(t_k^i, i, k, p_k^i, v_k^i, e^k_i)\}_{k=1}^{K^i}$$  is called *Quotes Stream*.
```


Table \@ref(tab:stamp-quote-frag) in section [Fragments of Quotes and Trades Streams] shows a fragment of ETHUSD Quotes Stream generated by Bitstamp during 1 second  
while table \@ref(tab:finex-quote-frag) shows similar fragment generated by Bitfinex.  They should be taken as a raw dataset for illustrations of reconstruction algorithm performance hereafter.



```{definition Trade, name="Trade", label=trade}
A tuple $\mathcal{S}_T[j] = (t_j, j, a_j, r_j, d_j, p_j, v_j)$ where

 a. $t_j \in \mathbb{R}_{>0}$ is a timestamp of the trade,
 a. $j \in \mathbb{N}$ is a unque trade identification number,
 b. $a_j \in \mathbb{N} \cup \{0\}$  is an optional taker (aggressing) quote identification number: if $a_j =`\{0\}$ then the number is not known,
 b. $r_j \in \mathbb{N} \cup \{0\}$ is an optional maker (resting) quote identification number: if $a_j =\{0\}$ then the number is not known,
 b. $d_j \in \{-1, +1\}$ is the side of the maker quote (if $d_j = -1$ then 'ask', otherwise 'bid')
 b. $p_j \in \mathbb{R}_{>0}$ is a trade price,
 b. $v_j \in \mathbb{R}_{\neq 0}$ is a trade volume
 
is called *trade*.  If $d_j = -1$ then the trade is a *buy trade*. Otherwise it is a *sell trade*.
```



```{definition Trades Stream, name="Trades Stream", label=trades-stream}
A set of trades $$\mathcal{S}_T = \{\mathcal{S}_T[j]\}_{j=1}^{J} = \{(t_j, j, a_j, r_j, d_j, p_j, v_j)\}_{j=0}^{J}$$ where 

 a. $j_1 \neq j_2 \implies \ (a_{j_1}, r_{j_1}) \neq (a_{j_2}, r_{j_2})$ 
 a. $j_1 < j_2 \implies t_{j_1} \leq t_{j_2}$
   
is called a *Trades Stream*.   

```

Table \@ref(tab:stamp-trade-frag) in section [Fragments of Quotes and Trades Streams] shows a fragment of ETHUSD Trades Stream generated by Bitstamp during 1 second  while table \@ref(tab:finex-trade-frag) shows similar fragment generated by Bitfinex. 




```{definition Empirical Order, name="Empirical Order", label=empirical-order}
An order $\hat{\mathbf{o}}^{i}(t)$ as defined by \@ref(def:order) which has been in some way constructed from the *quote* $\{(t_k^i, i, p_k^i, v_k^i)\}_{k=1}^{K^i} \in \mathcal{S}_Q$ as defined by \@ref(def:quote) is called an *empirical order*.
```


```{definition Empirical Order Book, name="Empirical Order Book", label=eob}
A set of empirical orders $\hat{\mathcal{O}} = \{\hat{\mathbf{o}}^i(t)\}_i$ is called *Empirical Order Book(EOB)*.
```





A typical exchange gives us some kind of event stream and, separately, some kind of trade stream with various level of details. 

As it is shown below, most of quote events may be uniquely utilized for construction of an empirical order since those quote events can be caused by  unique actions.  The only ambiguous exception is a volume decreasing quote event which may originate from

 a. A single fill 
 b. Multiple fills (i.e. several taker orders matched with a single maker order simultaneously)
 c. A cancellation
 d. Combination of the above (i.e. [Immediate or Cancel Order](https://www.investopedia.com/terms/i/immediateorcancel.asp))


These ambiguous volume decreasing quote events need, well, to be disambiguated before an empirical order can be constructed from the quote.



## Coupling

### Makers

```{definition Linkable Makers, name="Linkable Makers", label=linkable-makers}
Suppose that Quotes Stream $\mathcal{S}_Q$ and Trades Stream $\mathcal{S}_T$ are given. For each trade $\mathcal{S}_T[j] \in \mathcal{S}_T$ as defined by \@ref(def:trade), a (possibly empty) set $\mathcal{L}_R[\mathcal{S}_T[j]] = \{\mathcal{S}_Q^r[k]\}_{r, k}$ of a volume-decreasing quote events $\mathcal{S}_Q^r[k] \in \mathcal{S}_Q^r \in \mathcal{S}_Q$ as defined by \@ref(def:volume-decreasing-quote-event) that satisfy the following conditions:
  
  a. $\text{sgn}(v_k^r) = d_j$, i.e. $\mathcal{S}_Q^r$ is a resting (maker) quote for trade $j$,
  a. $r = r_j \lor r = 0$, i.e if trade $j$ contains maker quote identification number $r_j > 0$ then $\mathcal{S}_Q^r[k]$ must belong to quote $r_j$; otherwise it may belong to any other quote satisfying the other conditions of this definition,
  a. $t_k^r - t_j < \tau$, quote event $\mathcal{S}_Q^r[k]$ is no more than $\tau \in \mathbb{R}_{>0}$ seconds later than trade $j$ and *delay tolerance* $\tau$ is usually small,
  b. $p_k^r = p_j$,
  c. $\begin{cases} \Delta v_k^i \geq v_j, & k > 1 \\ e^i_k = D, & k = 1  \end{cases}$, i.e. the volume of trade $j$ is *smaller* that the volume decrease of quote $\mathcal{S}_Q^r$  at time $t_k^r$ or volume decrease is not defined and event type is a deletion,
  
is called *linkable makers ('resting' quotes) for trade $j$*. The set $\mathcal{L}_R = \bigcup_j \mathcal{L}_R[\mathcal{S}_T[j]]$ is called *linkable makers*.

```



```{definition Hidden Makers, name="Hidden Makers", label=hidden-makers}
Suppose that Quotes Stream $\mathcal{S}_Q$ and Trades Stream $\mathcal{S}_T$ are given.  For each trade $\mathcal{S}_T[j] \in \mathcal{S}_T$ as defined by \@ref(def:trade), a set $\mathcal{H}_R[\mathcal{S}_T[j]]$ defined as follows  $$
\mathcal{H}_R[\mathcal{S}_T[j]] = \mathcal{H}_R[(t_j, j, a_j, r_j, d_j, p_j, v_j)] = \{(t_j, j, 1, p_j, v_j, D)\}$$ is called *hidden maker for trade $j$*. The tuple $\{(t_j, j, 1, p_j, v_j, D)\} = \{\mathcal{S}_Q^j[1]\}$ is called a *hidden quote event for trade $j$*. The set $\mathcal{H}_R = \bigcup_j \mathcal{H}_R[\mathcal{S}_T[j]]$ is called *hidden makers*.

```



```{definition Maker Coupling, name="Maker Coupling", label=maker-coupling}
Suppose that Quotes Stream $\mathcal{S}_Q$ and Trades Stream $\mathcal{S}_T$ are given. A function $$
  \mathbf{l}_R(\cdot) :  \mathcal{S}_T \mapsto \mathcal{L}_R \cup \mathcal{H}_R
$$ such that $\forall j: \mathbf{l}_R(\mathcal{S}_T[j]) \in \mathcal{L}_R[\mathcal{S}_T[j]] \cup \mathcal{H}_R[\mathcal{S}_T[j]]$ is called a *maker coupling*. The symbol $\mathcal{L}_R^{\mathbf{l}_R}$ denotes the image of $\mathbf{l}_R(\cdot)$ function. 
```


If for some $j$ the cardinality of $\mathcal{L}_R[\mathcal{S}_T[j]]$ is greater than one then there are more than one different maker coupling $\mathbf{l}_R(\mathcal{S}_T[j])$ of Trade Stream $\mathcal{S}_T$ to Quotes Stream $\mathcal{S}_Q$. 


```{definition Inverse Maker Coupling, name="Inverse Maker Coupling", label=inverse-maker-coupling}
The (possibly empty) set $$\mathbf{l}_R^{-1}(\mathcal{S}^r_Q[k]) = \{ \mathcal{S}_T[j] : \mathbf{l}_R(\mathcal{S}_T[j]) = \mathcal{S}^r_Q[k] \in \mathcal{S}_Q \cup \mathcal{H}_R \}$$ is called an *inverse maker coupling set for quote event $\mathcal{S}^r_Q[k]$*.
```


```{definition Concordance of Volumes, name="Concordance of Volumes", label=concordance-volumes}
Suppose a maker coupling $\mathbf{l}_R(\mathcal{S}_T[j])$ as defined by \@ref(def:maker-coupling) is given. The functional $\mathscr{Q}(\mathbf{l}_R)_V$ calculated  as $$\mathscr{Q}_V(\mathbf{l}_R) = \sum_{\mathcal{S}^r_Q[k] \in \mathcal{L}_R^{\mathbf{l}_R}} \begin{cases} 0, & \text{ if }  \sum_{\mathcal{S}_T[j] \in \mathbf{l}_R^{-1}(\mathcal{S}^r_Q[k])} v_j 
 = v^i_k \land \mathcal{S}^r_Q[k] \not \in \mathcal{H}_R \\ -1, & \text{ if }  \sum_{\mathcal{S}_T[j] \in \mathbf{l}_R^{-1}(\mathcal{S}^r_Q[k])} v_j 
 = v^i_k \land \mathcal{S}^r_Q[k] \in \mathcal{H}_R \\  -1, & \text{ if } k = 1 \land e^i_k = D \\ -1, & \text{ if }  \sum_{\mathcal{S}_T[j] \in \mathbf{l}_R^{-1}(\mathcal{S}^r_Q[k])} v_j 
 < v^i_k \\ -\infty, & \text{ otherwise} \end{cases}$$ is called a *concordance of volumes*
```

The condition $k = 1 \land e^i_k = D$ in defintion \@ref(def:concordance-volumes) means that Quotes Stream has a deletion event for order $i$ without previous addition and/or change event(s). The volume decrease of the quote $i$ event $1$ is not defined and the reasonable decision in this situation is to assume that it is equal to the volume of the linked trade.


```{definition Concordance of Timestamps, name="Concordance of Timestamps", label=concordance-timestamps}
Suppose a maker coupling $\mathbf{l}_R(\mathcal{S}_T[j])$ as defined by \@ref(def:maker-coupling) is given. The functional $\mathscr{Q}(\mathbf{l}_R)_T$ calculated  as $$\mathscr{Q}_T(\mathbf{l}_R) = -\sum_{(\mathcal{S}_T[j], \mathbf{l}_R(\mathcal{S}_T[j])) }t^r_k - t_j$$
is called a *concordance of timestamps*
```


$\DeclareMathOperator*{\argmax}{arg\,max}$

```{definition Optimal Maker Coupling, name="Optimal Maker Coupling", label=optimal-maker-coupling}
Suppose that Quotes Stream $\mathcal{S}_Q$ and Trades Stream $\mathcal{S}_T$ are given. The maker coupling 
$$ \mathbf{l}_R^* = \argmax_{\argmax_{\mathbf{l}_R} \mathscr{Q}_V(\mathbf{l}_R)}\, \mathscr{Q}_T(\mathbf{l}_R)  $$ is called the *optimal maker copling*.

```


### Takers

Bitfinex does not provide quote events for takers while MOEX and Bitstamp do provide.

```{definition Linkable Takers, name="Linkable Takers", label=linkable-takers}
Suppose that Quotes Stream $\mathcal{S}_Q$ and Trades Stream $\mathcal{S}_T$ are given. For each trade $\mathcal{S}_T[j] \in \mathcal{S}_T$ as defined by \@ref(def:trade), a non-empty set of a volume-decreasing quote events $\mathcal{S}_Q^i[k] \in \mathcal{S}_Q^i \in \mathcal{S}_Q$ as defined by \@ref(def:volume-decreasing-quote-event) that satisfy the following conditions:
  
  a. $|t_j - t_k^i| < \tau$, where $\tau$ is a constant,
  a. $i = a_j$ if the trade contains taker quote identification number,
  b. $p_k^i d_j \leq p_j d_j$,
  b. $\text{sgn}(v_k^i) = -d_j$,
  c. $|v_k^i - v_{k-1}^i| \geq v_j$
  
is called *linkable takers for trade $j$*.

```

TBD

## Order Intervals Reconstruction

To reconstruct an empirical order $\hat{\mathbf{o}}^{i}(t)$ as defined by \@ref(def:empirical-order) from the *Quotes Stream* $\mathcal{S}_Q^i$ as defined by \@ref(def:quotes-stream) one needs to define the set of intervals $\mathcal{T^i}$ since order prices $\mathcal{P}^i$ and order volumes $\mathcal{V}^i$ are unambiguously defined by the Quotes Stream $\mathcal{S}_Q^i$.

TBD
 


## Enforcement of IME condition in EOB

TBD

## Enforcement of VC condition in EOB

TBD

# Results

## Fragments of Quotes and Trades Streams

In the tables below all order events and trades are shown in the order in which they were received from an exchange. 

### Bitstamp Quotes 


```{r Sample Bitstamp Quotes Stream, eval=TRUE, echo=FALSE}

as_hux(stamp.q.1[order(local_timestamp), # i.e. in the order events were received from Bitstamp
                    .(`#`=n,
                    `\\(t^i_k\\)`=microtimestamp,
                    `\\(i\\)`=as.character(order_id),
                    `\\(k\\)`=k,
                    `\\(p^i_k\\)`=price,
                    `\\(v^i_k\\)`=ifelse(order_type=="buy", 1,-1)*amount,
                    `\\(e^i_k\\)`=event,
                    `\\(\\Delta v^i_k \\)`=fifelse(volume.decrease > 0, sprintf("%.4f", volume.decrease), ""))
                    ], 
       scientific=F) %>%
  add_colnames() %>%
  set_align(1, 2:3, 'center') %>%
  set_align(1, c(1, 4:7), 'right') %>%
  set_escape_contents(2,everywhere,value=TRUE) %>%
  set_number_format(row=everywhere, col=5:6,value="%.2f") %>%
  #set_number_format(row=everywhere, col=8,value="%.4f") %>%
  set_caption('(#tab:stamp-quote-frag) A fragment of ETHUSD Quotes Stream generated by Bitstamp during 1 second. Only positive \\(\\Delta v^i_k \\) are shown to facilitate a comparison with Trades Stream since only positive volume decreases should be in concordance with trade volumes. Imperfections of Bitstamp\'s data are numerous and obvious.') %>%
  set_caption_pos("topleft")
  

```

### Bitstamp Trades 

```{r Sample Bitstamp Trades Stream, eval=TRUE, echo=FALSE}

as_hux(stamp.t.1[order(local_timestamp),.(`#`=n,
                    `\\(t_j\\)`=trade_timestamp,
                    `\\(j\\)`=as.character(bitstamp_trade_id),
                    `\\(a_j\\)`=as.character(ifelse(trade_type =="buy", sell_order_id, buy_order_id)),
                    `\\(r_j\\)`=as.character(ifelse(trade_type =="sell", sell_order_id, buy_order_id)),
                    `\\(d_j\\)`=ifelse(trade_type =="buy", -1, 1),
                    `\\(p_j\\)`=price,
                    `\\(v_j\\)`=amount)
                    ], 
       scientific=F) %>%
  add_colnames() %>%
  set_align(1, 2:6, 'center') %>%
  set_align(1, c(1,7:8), 'right') %>%
  set_escape_contents(2,everywhere,value=TRUE) %>%
  set_number_format(row=everywhere, col=7,value="%.2f") %>%
  set_number_format(row=everywhere, col=8,value="%.4f") %>%
  set_caption('(#tab:stamp-trade-frag) A fragment of ETHUSD Trades Stream generated by Bitstamp during 1 second.') %>%
  set_caption_pos("topleft")
  

```


### Bitfinex Quotes



```{r Sample Bitfinex Quotes Stream, eval=TRUE, echo=FALSE}

as_hux(finex.q.1[order(local_timestamp),.(`#`=.I,
                    `\\(t^i_k\\)`=exchange_timestamp,
                    `\\(i\\)`=as.character(order_id),
                    `\\(k\\)`=k,
                    `\\(p^i_k\\)`=price,
                    `\\(v^i_k\\)`=amount,
                    `\\(e^i_k\\)`=event,
                    `\\(\\Delta v^i_k \\)`=fifelse(volume.decrease > 0, sprintf("%.4f", volume.decrease), ""))
                    ], 
       scientific=F) %>%
  add_colnames() %>%
  set_align(1, 2:3, 'center') %>%
  set_align(1, c(1,4:7), 'right') %>%
  set_escape_contents(2,everywhere,value=TRUE) %>%
  set_number_format(row=everywhere, col=5:6,value="%.5f") %>%
  #set_number_format(row=everywhere, col=8,value="%.4f") %>%
  set_caption('(#tab:finex-quote-frag) A fragment of ETHUSD Quotes Stream generated by Bitfinex during 1 second. Only positive \\(\\Delta v^i_k \\) are shown to facilitate a comparison with Trades Stream since only positive volume decreases should be in concordance with trade volumes. Bitfinex does not report quote amount at deletion event so in the table below it is assumed zero and it leads to an excessive number of volume-decreasing events.') %>%
  set_caption_pos("topleft")
  

```

### Bitfinex Trades

```{r Sample Bitfinex Trades Stream, eval=TRUE, echo=FALSE}

as_hux(finex.t.1[order(local_timestamp),.(`#`=.I,
                    `\\(t_j\\)`=exchange_timestamp,
                    `\\(j\\)`=as.character(id),
                    `\\(a_j\\)`="0",
                    `\\(r_j\\)`="0",
                    `\\(d_j\\)`=d,
                    `\\(p_j\\)`=price,
                    `\\(v_j\\)`=abs(qty))
                    ], 
       scientific=F) %>%
  add_colnames() %>%
  set_align(1, 2:6, 'center') %>%
  set_align(1, c(1,7:8), 'right') %>%
  set_escape_contents(2,everywhere,value=TRUE) %>%
  set_number_format(row=everywhere, col=7,value="%.5f") %>%
  set_number_format(row=everywhere, col=8,value="%.5f") %>%
  set_caption('(#tab:finex-trade-frag) A fragment of ETHUSD Trades Stream generated by Bitfinex during 1 second.') %>%
  set_caption_pos("topleft")
  

```

## Optimal Maker Coupling for Fragments

### Bitstamp

Optimal Maker Coupling as defined by \@ref(def:optimal-maker-coupling) function relates every trade in the fragment of Bitstamp Trades Stream to volume decreasing quote events.  Table \@ref(tab:stamp-optimal-maker-coupling) shows the specification of the function where column `T #` contains row numbers of trades in table \@ref(tab:stamp-trade-frag) and column `Q #` contains row numbers of corresponding quote events in table \@ref(tab:stamp-quote-frag).

The other columns are copied from tables \@ref(tab:stamp-quote-frag) and \@ref(tab:stamp-trade-frag) for illustration.


```{r Bitstamp Optimal Maker Coupling specification, echo=FALSE}
as_hux(
  rbind(
    stamp.q.1[ k == 1 & event == 'D'][stamp.t.1[trade_type == 'buy'], .(quote.n=n, trade.n=i.n, trade_timestamp, microtimestamp, q.p=price, t.p=i.price, volume.decrease, t.v=i.amount, event, trade_type,k ), on=.(order_id = sell_order_id), nomatch=NULL],
    stamp.q.1[stamp.t.1[trade_type == 'buy'],.(quote.n=n,trade.n=i.n, trade_timestamp, microtimestamp, q.p=price, t.p=i.price, volume.decrease, t.v=i.amount, event, trade_type,k ), on=.(order_id = sell_order_id, volume.decrease=amount), nomatch=NULL],
    stamp.q.1[stamp.t.1[trade_type == 'sell'],.(quote.n=n,trade.n=i.n, trade_timestamp, microtimestamp, q.p=price, t.p=i.price, volume.decrease, t.v=i.amount, event, trade_type,k  ), on=.(order_id = buy_order_id, volume.decrease=amount), nomatch=NULL]
  )[order(trade.n),.(
    `T #`=trade.n,
    `Q #`=quote.n,
    `\\(t_j = t^i_k\\)`=trade_timestamp,
    `\\(p_j = p^i_k\\)`=t.p,
    `\\(v_j\\)`=t.v,
    `\\(\\Delta v^i_k \\)`=sprintf("%.4f", volume.decrease),
    `\\(d_j\\)`=ifelse(trade_type =="buy", -1, 1),
    `\\(k\\)`=k,
    `\\(e^i_k\\)`=event )
    ]
) %>%
  add_colnames() %>%
  set_align(1, 3, 'center') %>%
  set_align(1, c(1:2,4:9), 'right') %>%
  #set_escape_contents(1,everywhere,value=TRUE) %>%
  set_number_format(row=everywhere, col=4,value="%.2f") %>%
  set_number_format(row=everywhere, col=5:6,value="%.4f") %>%
  set_background_color(21, everywhere, value="grey90") %>%
set_caption('(#tab:stamp-optimal-maker-coupling) The specification of Optimal Maker Coupling function for fragments of ETHUSD Quotes and Trades streams generated by Bitstamp. Note that in row 20 the volume decrease \\(\\Delta v^i_k \\) is equal to zero, event type \\(e^i_k\\) is a deletion and \\(k = 1\\)') %>%
  set_caption_pos("topleft")

```


### Bitfinex

Optimal Maker Coupling as defined by \@ref(def:optimal-maker-coupling) function relates every trade in the fragment of Bitfinex Trades Stream to quote events.  Table \@ref(tab:finex-optimal-maker-coupling) shows the specification of the function where column `T #` contains row numbers of trades in table \@ref(tab:stamp-trade-frag) and column `Q #` contains row numbers of corresponding quote events in table \@ref(tab:stamp-quote-frag). Rows with empty `Q #` corresponds to trades where Optimal Maker Coupling function has a value from hidden maker set as defined by \@ref(def:hidden-makers).

The other columns are copied from tables \@ref(tab:finex-quote-frag) and \@ref(tab:finex-trade-frag) for illustration.



```{r Bitfinex Optimal Maker Coupling specification, echo=FALSE}
finex.digits <- 5
finex.m.1 <-  rbind(
    finex.q.1[amount <=0 ][finex.t.1[d < 0], .(quote.n=n, trade.n=i.n, exchange_timestamp, trade_timestamp=i.exchange_timestamp,  price, d, event, k, volume.decrease=fifelse(!is.na(exchange_timestamp), volume.decrease,NA_real_), qty ), on=.(volume.decrease = qty, price=price)],
    finex.q.1[amount >=0 ][finex.t.1[d > 0], .(quote.n=n, trade.n=i.n, exchange_timestamp,trade_timestamp=i.exchange_timestamp,  price,  d, event, k, volume.decrease=fifelse(!is.na(exchange_timestamp), volume.decrease,NA_real_), qty ), on=.(volume.decrease = qty, price=price)])
finex.m.2 <- finex.m.1[is.na(exchange_timestamp) & d < 0][
  finex.q.1[amount <=0 ][
    finex.m.1[is.na(exchange_timestamp) & d < 0,.(qty=round(sum(qty),finex.digits)), by=price],.(exchange_timestamp, event,price, volume.decrease, n), on=.(volume.decrease = qty, price=price),nomatch=NULL]
    , .(quote.n=n, trade.n, exchange_timestamp=i.exchange_timestamp,trade_timestamp,  price,  d, event=i.event, k, volume.decrease=i.volume.decrease, qty )
    , on=.(price=price)]

finex.m.1 <- rbind(
  finex.m.1[!trade.n %in% finex.m.2$trade.n, ],
  finex.m.2
  )
as_hux(finex.m.1[order(trade.n),.(
      `T #`=trade.n,
      `Q #`=quote.n,
      `\\(t_j\\)`=format(trade_timestamp, format="%H:%M:%OS3"),
      `\\(t^i_k\\)`=format(exchange_timestamp, format="%H:%M:%OS3"),
      `\\(p_j = p^i_k\\)`=price,
      `\\(v_j \\)`=sprintf("%.4f", qty),
      `\\(\\Delta v^i_k \\)`=fifelse(sprintf("%.4f", volume.decrease) == "NA"," ", sprintf("%.4f", volume.decrease)),
      `\\(d_j\\)`=d,
      `\\(k\\)`=k,
      `\\(e^i_k\\)`=event )
    ]
) %>%
  add_colnames() %>%
  set_align(1, 3:4, 'center') %>%
  set_align(1, c(1:2,5:9), 'right') %>%
  set_number_format(row=everywhere, col=5:6,value="%.5f") %>%
  set_background_color(c(FALSE, finex.m.1[order(trade.n)][, qty < volume.decrease]), everywhere, value="grey90") %>%
set_caption('(#tab:finex-optimal-maker-coupling) The specification of Optimal Maker Coupling function for fragments of ETHUSD Quotes and Trades streams generated by Bitfinex. Rows with empty column Q # shows trades with hidden makers. Note that in several cases many trades are mapped to a single quote event.') %>%
  set_caption_pos("topleft")

```


# Discussion

TBD





# References





